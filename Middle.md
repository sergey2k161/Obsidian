||**.Net**||
|1|Что такое .NET framework ?|[Net Framework](https://conf.bars.group/display/GKHSZ/Net+Framework)|
|2|Опишите **CLR**||
|3|Опишите **FCL**||
|4|Опишите **CLS**||
|5|Опишите **CIL**||
|6|Что такое сборка (**Assembly**) ?|[Сборки](https://conf.bars.group/pages/viewpage.action?pageId=187706590)|
|7|Что такое **GAC** ? Какую проблему он разрешает?||
|8|Что такое частные и общие сборки ?|[Сборки](https://conf.bars.group/pages/viewpage.action?pageId=187706590)|
|9|Какие методы класса **Object** вы знаете ?||
|10|Что такое **Value Type** и **Reference Type** ? Назовите различия между ними.||
|11|Ваше понимание упаковки (**Boxing**) и распаковки (**Unboxing**). Приведите пример.||
|12|Может ли значение типа **DateTime** принимать значение **null** ?||
|13|Перечисления (**Enum**) это Value type или Reference type ?||
|14|Какие типы могут быть использованы в качестве значений перечисления ?||
|15|Строки (**String**) это Value type или Reference type ?||
|16|Ваше понимание **immutable**.||
|17|Что происходит в процессе конкатенации строк ?||
|18|Дан массив строк  <br>var strArray = new[]{"Str1","Str2","Str3"……"Str1000"}  <br>Какими механизмами вы воспользуетесь для формирования строки, содержащей все элементы массива с разделителями ? Почему именно эти механизмы ?||
|19|Ваше понимание работы класса **StringBuilder**. Есть ли преимущество перед использованием **String** ?||
|20|Модификатор **abstract**||
|21|В каком случае вы обязаны использовать модификатор **abstract** ?||
|22|Модификатор **sealed**||
|23|Может ли класс одновременно иметь модификаторы **asbtract** и **sealed** ?||
|24|Модификатор **virtual**||
|25|В чем разница между абстрактными и виртуальными методами ?||
|26|Модификатор **protected**||
|27|Модификатор **internal**||
|28|Модификатор **private**||
|29|Наследуются ли члены класса с модификатором **private** ?||
|30|Модификатор **new**||
|31|Модификатор **protected internal**||
|32|Модификатор **static**||
|33|Ваше понимание статического класса||
|34|Ваше понимание статического метода||
|35|Ваше понимание **Extension**-методов. Как объявить метод расширения ?||
|36|Ваше понимание **Delegate** и **Multicast Delegate.**||
|37|Может ли **Delegate** принимать значение **null** ?||
|38|Ваше понимание **Event**||
|39|Может ли **Event** принимать значение **null** ?||
|40|Ваше понимание анонимного метода, **lambda**-выражений|[Лямбда выражения](https://conf.bars.group/pages/viewpage.action?pageId=187706547)|
|41|Ваше понимание абстрактного класса|[Абстрактный класс](https://conf.bars.group/pages/viewpage.action?pageId=187706536)|
|42|Чем перекрытый метод отличается от перегруженного метода ?|[Перекрытие и перегрузка метода](https://conf.bars.group/pages/viewpage.action?pageId=187706567)|
|43|Ваше понимание интерфейса|[Интерфейсы](https://conf.bars.group/pages/viewpage.action?pageId=187706545)|
|44|В чем отличие абстрактного класса от интерфейса ?||
|45|Может ли интерфейс содержать делегаты ?|[Делегаты, Linq](https://conf.bars.group/pages/viewpage.action?pageId=187706541)|
|46|Может ли интерфейс содержать события (**Event**) ?||
|47|Возможно ли множественное наследование интерфейсов в C# ?||
|48|Возможно ли множественное наследование классов в C# ?||
|49|Возможно ли разрешить наследование класса, но запретить перекрытие метода?||
|50|Даны два интерфейса:  <br>public interface IWorkerA { int DoWork(); }  <br>public interface IWorkerB { int DoWork(); }<br><br>Каким образом реализовать оба интерфейса в одном классе  <br>public class Worker: IWorkerA, IWorkerB {} ?||
|51|Опишите различие между **readonly** полями и константами.||
|52|Ваше понимание инструкций **is** и **as**|[Приведение типов](https://conf.bars.group/pages/viewpage.action?pageId=187706577)|
|53|Дан следующий код:  <br>var value = 1;  <br>1: var result = (TType)value;  <br>2: var result = (value as TType)<br><br>Что произойдет если в выражении (TType)value, значение value не приводимо к типу TType ?<br><br>Что произойдет если в выражении (value as TType), значение value не приводимо к типу TType ?<br><br>Что произойдет если в выражении (value as TType), значение value является Value Type ?<br><br>Что произойдет если в выражении (value as TType), значение value является Reference Type, не приводимым к TType ?||
|54|Ваше понимание обобщенных (**generic**) типов||
|55|Какую проблему решали обобщенные коллекции ?||
|56|Ваше понимание ключевого слова **default**||
|57|Ваше понимание ограничений параметров обобщенных типов||
|58|Что можно использовать в качестве аргумента в конструкции **foreach** ?||
|59|Ваше понимание **IEnumerable**, **IEnumerator**?||
|60|Ваше понимание **Array**|[Массивы](https://conf.bars.group/pages/viewpage.action?pageId=187706549)|
|61|Объясните разницу между **System.Array.CopyTo()** и **System.Array.Clone()**||
|62|Ваше понимание коллекций и списков||
|63|Ваше понимание **IDictionary<TKey,TValue>**||
|64|В чем разница между **IDictionary.Add(key, value)** и **IDictionary[key] = value**||
|65|Дан код:  <br>var dictionary = new Dictionary<string, string>();  <br>…..  <br>foreach(var item in dictionary){}<br><br>Какой тип у item ?||
|66|Опишите процесс перехвата исключительных ситуаций||
|67|Можно ли написать несколько блоков **catch** для  одного оператора **try** ?||
|68|Можно ли выполнить несколько блоков **catch** для одного оператора **try** ?||
|69|Есть ли отличие в **catch(Exception e){throw e;}** и  **catch(Exception e){throw;}** ?||
|70|Будет ли выполнен блок finally, если не было сгенерировано исключение ?  <br>"Дан код:  <br>try { DoWork(); return 1; } catch(Exception ex) { Log(ex); return 2; } finally { return 3; }"<br><br>  Какое значение будет возвращено в случае возникновения исключительной ситуации в методе DoWork ?<br><br>  Какое значение будет возвращено в случае если метод DoWork отработает без ошибок ?||
|71|Ваше понимание перегрузки методов||
|72|Ваше понимание рекурсии|[Рекурсия](https://conf.bars.group/pages/viewpage.action?pageId=187706581)|
|73|Ваше понимание модификаторов **ref** и **out**||
|74|Ваше понимание ключевого слова **params**|[Params, default](https://conf.bars.group/display/GKHSZ/Params%2C+default)|
|75|"Дан код:  <br>public class Node { public Node Parent {get;set;} public string Name {get;set;} public IEnumerable Children{get;set;} }  <br>У корневого узла Parent всегда равен null;  <br>Предоставлен корневой узел дерева, содержащий несколько уровней  <br>Node root = ReadXml();"  <br>Напишите Extension-метод, возвращающий Уровень текущего узла относительно корня  <br>Напишите метод рекурсивного обхода дерева, выводящий на консоль узлы в формате Уровень-Наименование||
||**Операторы SQL**||
|76|Операторы **DDL**||
|77|Операторы **DML**||
|78|Операторы защиты и управления данными||
|79|Виды **JOIN**||
|80|Что такое **HAVING** и чем отличается от **GROUP BY**||
|81|Что такое индекс и какие виды индексов есть в БД продукта?||
|82|Как посмотреть список выполняющихся запросов в БД продукта?||
|83|Что такое план запроса и как его читать?||
|84|Что такое транзакция?||
|85|Как реализовать постраничный просмотр средствами **SQL**?|