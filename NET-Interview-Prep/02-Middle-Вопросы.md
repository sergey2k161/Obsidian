# C# и .NET - Вопросы для Middle Developer

## Сборка мусора и управление памятью

### 1. Как происходит сборка мусора в .NET?

GC (Garbage Collector) автоматически освобождает память, занятую объектами, на которые больше нет ссылок.  
Работает по поколениям (0, 1, 2): молодые объекты — часто собираются, старые — реже.  
Сборка выполняется, когда:

- не хватает памяти,
    
- система простаивает,
    
- вручную вызван `GC.Collect()`.
### 2. Как вызвать сборщик мусора из кода, в каких случаях это целесообразно?

```csharp
GC.Collect();
GC.WaitForPendingFinalizers();
```

Использовать только в крайних случаях (например, после выгрузки большого объёма данных), т.к. это блокирует выполнение и ухудшает производительность. В обычной работе — **не нужно**.
### 3. В какой момент срабатывает статический конструктор класса?

Перед первым обращением к классу (доступ к полю, методу, созданию экземпляра).  
Гарантируется, что выполнится **один раз и потокобезопасно**.
## Делегаты и события

### 4. Можно ли добавить дополнительную обработку при подписывании делегата на событие?

Да. Через явное объявление события с `add` и `remove`:

```csharp
private EventHandler _handler; 
public event EventHandler MyEvent 
{    
	add { Console.WriteLine("Подписка"); _handler += value; }     
	remove { Console.WriteLine("Отписка"); _handler -= value; } 
}
```
### 5. Потокобезопасность событий

Дан код:
```csharp
public class Worker
{
    public event EventHandler OnWork;
    public void DoWork() { ….. OnWork(this, null) }
}
```

**Вопросы:**
- В каком случае при вызове OnWork возникнет исключительная ситуация? Смодифицируйте код чтобы исключительная ситуация не возникла.
```csharp
OnWork?.Invoke(this, null);
```
- Как необходимо модифицировать вызов OnWork в многопоточном окружении, при условии что несколько потоков подписываются на событие OnWork и отписываются от него?
```csharp
var handler = OnWork;
handler?.Invoke(this, null);
```

## Структуры (struct)

### 6. Могут ли структуры (struct) имплементировать интерфейсы?

**Да**, могут. Но при приведении к интерфейсу происходит boxing (упаковка в heap).
### 7. Могут ли структуры (struct) иметь статический конструктор?

**Да**, могут. Работает так же, как в классах.
### 8. Могут ли структуры (struct) содержать события (event)?

Да, могут, но крайне редко используется.
### 9. Могут ли структуры содержать только конструкторы с параметрами?

Нет. У каждой структуры **обязательно есть неявный конструктор без параметров**, который инициализирует поля значениями по умолчанию.
## LINQ и IQueryable

### 10. Ваше понимание IQueryable. В чем ключевое отличие от IEnumerable?

- **IEnumerable** - работает в памяти, выполняется на клиенте (LINQ to Objects)
- **IQueryable** - строит дерево выражений (Expression Tree), которое переводится в SQL/другой язык запросов, выполняется на сервере БД
### 11. В какой момент применяется условие отбора, указанное в методе расширения .Where(x=>….)? Можно ли это изменить?

Для `IEnumerable` — при **итерации** (`foreach`).  
Для `IQueryable` — когда выполняется **запрос к источнику**.  
Изменить — можно, вызвав `.ToList()`, `.ToArray()` — форсирует выполнение.
### 12. Ваше понимание Linq

LINQ (Language Integrated Query) — единый способ писать запросы к коллекциям, БД, XML и т.п.  
Главная идея — **декларативный стиль** вместо циклов.
### 13. Ваше понимание Expression

`Expression` — дерево выражений, представляющее код как структуру данных.  
Используется, чтобы **анализировать** и **преобразовывать** код (например, в SQL).

### 14. В чем отличие Func<string> от Expression<Func<string>>?
- `Func` — содержит **делегат (исполняемый код)**.
    
- `Expression<Func>` — содержит **дерево выражений (описание кода)**.  
    Пример: `x => x.Age > 18`
    
- `Func` выполняется,
    
- `Expression<Func>` — может быть проанализирован (например, ORM его переводит в SQL).

## IDisposable и управление ресурсами

### 15. Ваше понимание IDisposable. Для чего применяется?

Интерфейс для **освобождения неуправляемых ресурсов** (файлы, соединения, потоки).  
Метод `Dispose()` вызывается вручную или через `using`.

### 16. Ваше понимание секции using (var value = ...)

Гарантирует вызов `Dispose()` даже при исключении.  
Упрощает очистку ресурсов.

### 17. В какую конструкцию разворачивается using? Напишите аналог using-секции
```csharp
// using (var resource = new Resource()) 
// { /* код */ }

Resource resource = new Resource(); 
try 
{ 
	// код
} 
finally 
{ 
	resource?.Dispose(); 
}
```

### 18. Отличие Dispose от Finalize

- `Dispose` — вызывается вручную, сразу освобождает ресурсы.
    
- `Finalize` (деструктор) — вызывается GC **непредсказуемо**, когда объект уничтожается.  
    Обычно `Dispose` вызывает `GC.SuppressFinalize(this)`.

### 19. Можно ли объявить деструктор класса? Если да, то наследуются ли деструкторы?

Да, можно (`~ClassName()`), но **не наследуются**.

### 20. Можно ли вызвать деструктор класса принудительно?

Нет. Он вызывается **только GC**.

### 21. Можно ли объявить деструктор структур?

Нет. Только классы могут иметь деструкторы.

## Многопоточность

### 22. Объясните разницу между нитью (Thread) и процессом (Process)

- **Process** — независимая программа с собственной памятью.
    
- **Thread** — поток внутри процесса, разделяет память с другими потоками.

### 23. В чем разница между Thread и Task?

- `Thread` — низкоуровневый поток.
    
- `Task` — более высокоуровневая абстракция для **асинхронных операций**, использует пул потоков.

### 24. Чем отличаются Task<T> и ValueTask<T>?

`ValueTask` — структурная обёртка, оптимизированная для случаев, когда результат **уже готов**.  
`Task` — всегда создаёт объект, `ValueTask` экономит аллокации, но сложнее в использовании.

### 25. Что такое потокобезопасность?

Свойство кода корректно работать при **одновременном доступе из нескольких потоков** без гонок данных.

### 26. Как проводится синхронизация потоков?

Через механизмы:

- `lock`,  `Monitor`, `Mutex`, `Semaphore`, `ReaderWriterLockSlim`,
    
- атомарные операции (`Interlocked`),
    
- `Concurrent` коллекции.

### 27. Что такое пул потоков, как с ним работать?

ThreadPool - набор переиспользуемых потоков. Избегает накладных расходов на создание/уничтожение. Используется через `Task.Run()`, `ThreadPool.QueueUserWorkItem()`.

### 28. Является ли статический конструктор потокобезопасным?

**Да**, CLR гарантирует однократный и потокобезопасный вызов.

### 29. Является ли статическая инициализация полей потокобезопасной?

Да. Инициализация статических полей выполняется один раз и синхронизирована CLR.

### 30. Ваше понимание double-check-locking

Паттерн для ленивой инициализации с блокировкой:

`if (_instance == null) {     lock(_lock)     {         if (_instance == null)             _instance = new Singleton();     } }`

Первичная проверка — чтобы не блокировать каждый раз,  
вторая — чтобы избежать гонки при первом создании.

### 31. Ваше понимание выражения lock(value), в какую конструкцию разворачивается lock?

lock(obj) { ... }
разворачивается в:

csharp
Копировать код
object temp = obj;
bool lockTaken = false;
try
{
    Monitor.Enter(temp, ref lockTaken);
    ...
}
finally
{
    if (lockTaken) Monitor.Exit(temp);
}

## Асинхронность

### 32. В чем отличие между параллельностью и асинхронностью?

- **Параллельность** — выполнение нескольких операций **одновременно** (много потоков).
    
- **Асинхронность** — выполнение задач **без блокировки** потока (ожидание не занимает поток).  
    Пример: асинхронность — “пока жду ответ от сервера, делаю что-то ещё”, параллельность — “обрабатываю 4 файла одновременно”.

### 33. Какую задачу решает модификатор async?

Позволяет методу использовать `await` и автоматически оборачивает результат в `Task` или `Task<T>`.  
Он **не делает метод асинхронным сам по себе**, а просто позволяет использовать асинхронные операции.

### 34. Для чего нужен оператор await?

`await` приостанавливает выполнение метода до завершения асинхронной операции, **не блокируя поток**.  
После завершения — выполнение продолжается.

## Атрибуты

### 35. Каким образом можно пометить метод как устаревший?

Через атрибут `[Obsolete]`:

### 36. Какие элементы могут быть помечены каким-либо атрибутом?

Практически **всё**: классы, методы, свойства, поля, параметры, сборки, интерфейсы, конструкторы, перечисления и т.д.  
(определяется `AttributeTargets`).

## Reflection (Механизм отражений)

### 37. Ваше понимание механизма отражений (Reflection)

Reflection — механизм для **исследования и модификации метаданных** и структуры типов во время выполнения.  
Позволяет динамически:

- получать типы, методы, свойства,
    
- создавать объекты,
    
- вызывать методы,
    
- читать атрибуты.

### 38. Как бы вы реализовали механизм плагинов?

- Определить интерфейс плагина
- Загрузить сборку: `Assembly.LoadFrom()`
- Найти типы с нужным интерфейсом: `assembly.GetTypes().Where(t => typeof(IPlugin).IsAssignableFrom(t))`
- Создать экземпляры: `Activator.CreateInstance(type)`

### 39. Каким образом можно получить список полей, свойств и методов класса?

```csharp
var type = typeof(MyClass);
var fields = type.GetFields();
var props = type.GetProperties();
var methods = type.GetMethods();
```

### 40. Каким образом можно получить список конструкторов и выбрать конструктор по-умолчанию?

var type = typeof(MyClass);
var ctors = type.GetConstructors();
var defaultCtor = type.GetConstructor(Type.EmptyTypes);

### 41. Можно ли выполнить приватный метод?

var method = type.GetMethod("MyPrivate", BindingFlags.NonPublic | BindingFlags.Instance);
method.Invoke(obj, null);


## Сборки (Assemblies)

### 42. Опишите применение класса Activator

Используется для **динамического создания объектов**, когда тип неизвестен на этапе компиляции:

`var obj = Activator.CreateInstance(typeof(MyClass));`

### 43. Какие методы загрузки сборок в домен вы знаете? В чем их отличие?

- `Assembly.Load(string name)` — по имени (из GAC или текущего домена).
    
- `Assembly.LoadFrom(path)` — с конкретного пути.
    
- `Assembly.LoadFile(path)` — без зависимостей.  
    `LoadFrom` предпочтительнее для плагинов, `Load` — для известных сборок.

### 44. Что такое AssemblyManifest?

Манифест — часть сборки, содержащая **метаданные**:

- имя сборки, версия, культура,
    
- список файлов,
    
- зависимости,
    
- информация о безопасности.


### 45. В чем разница между AOT и JIT компиляцией? Какие преимущества и ограничения у каждого из них?

- **JIT** (Just-In-Time) - компиляция во время выполнения, медленный старт, оптимизация под конкретное железо
- **AOT** (Ahead-Of-Time) - компиляция до выполнения, быстрый старт, меньший размер, но менее гибкая оптимизация

### 46. Как производится публикация приложения на .NET? Какие есть ключи публикации?

Через `dotnet publish` с параметрами:

- `--configuration Release`
    
- `--runtime win-x64`
    
- `--self-contained true` (самодостаточная сборка)
    
- `--framework net8.0`  
    Типы:
    
- **Framework-dependent** — требует установленный .NET.
    
- **Self-contained** — включает рантайм.
    
- **Single file** — всё в один файл.

### 47. Можно ли в сборке хранить дополнительные ресурсы (файлы)? Если да, каким образом можно получить список этих ресурсов и выгрузить отдельный ресурс?

Да, можно добавлять **Embedded Resource**.  
Получение:

`var asm = Assembly.GetExecutingAssembly(); var names = asm.GetManifestResourceNames(); using var stream = asm.GetManifestResourceStream("Namespace.File.txt");`

### 48. Какие атрибуты сборок (assembly) вы знаете?

[assembly: AssemblyTitle("MyApp")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyCompany("MyCompany")]
[assembly: AssemblyDescription("Описание сборки")]

## ORM

### 49. Ваше понимание ORM. Какими вы пользовались?

ORM (Object-Relational Mapping) — связывает объекты .NET с таблицами БД.  
Позволяет писать запросы на C#, а не SQL.  
Примеры: **Entity Framework, Dapper (частично)**.

### 50. Ваше понимание Lazy Loading

Загрузка связанных данных **по требованию**, а не сразу.  
Пример: объект `User` загружен, а `User.Orders` подгрузится только при обращении.  
Плюс — экономия запросов, минус — возможные "N+1" запросы.

## NHibernate

### 51. Почему все публичные свойства и методы должны иметь модификатор virtual?

Потому что NHibernate создает **прокси-классы** для ленивой загрузки и отслеживания изменений.  
Для этого ему нужно **переопределять** члены.

### 52. Ваше понимание IUserType

Интерфейс для создания **пользовательского типа** в NHibernate — когда стандартное сопоставление не подходит.  
Позволяет определить, как тип сохраняется и читается из БД.

### 53. Ваше понимание Formula

Позволяет задать **вычисляемое свойство** через SQL-выражение:

`<property name="TotalPrice" formula="Quantity * Price" />`

Не хранится в таблице — вычисляется при запросе.

### 54. Каковы различия между Bag и Set?

- **Bag** — список (допускает дубликаты, неупорядочен).
    
- **Set** — множество (уникальные элементы).  
    Используются в отображении коллекций в XML mapping.
    
## IoC/DI

### 55. Ваше понимание IoC/DI

- **IoC (Inversion of Control)** — принцип, при котором зависимостями управляет контейнер, а не код.
    
- **DI (Dependency Injection)** — способ реализации IoC, когда зависимости **внедряются** (через конструктор, свойства или методы).

### 56. Какие стратегии DI вы знаете?

- **Constructor Injection** — через параметры конструктора (наиболее распространён).
    
- **Property Injection** — через свойства.
    
- **Method Injection** — через параметры метода.
    
- **Service Locator** — через обращение к контейнеру (не рекомендуется).

### 57. Ваше понимание Lifestyle Management. Перечислите основные (не зависимо от фреймворка)

Определяет, **как долго живёт** объект в контейнере:

- **Transient** — создаётся каждый раз заново.
    
- **Singleton** — один на всё приложение.
    
- **Scoped** — один на каждый запрос/операцию.
    
- (иногда) **PerThread** — один на поток.

### 58. Какие IoC контейнеры вам известны?

- **Microsoft.Extensions.DependencyInjection** (встроенный в .NET)
    
- **Autofac**
    
- **Ninject**
    
- **Castle Windsor**
    
- **Unity**
    
- **StructureMap**

## Castle.Windsor

### 59. Вы использовали Castle.Windsor?


### 60. Ваше понимание parent-child container (SubContainer в Castle.Windsor)


### 61. Ваше понимание sub resolver (SubDependencyResolver в Castle.Windsor)


### 62. Ваше понимание ComponentRegistration.UsingFactoryMethod


### 63. Ваше понимание ComponentRegistration.Forward


### 64. Ваше понимание ComponentRegistration.Named


### 65. Какими способами можно подменить имплементацию контракта?


### 66. Что используется в качестве имени по-умолчанию?


## Равенство и сравнение объектов

### 67. В чем отличие равенства от идентичности объектов?

- **Равенство (`Equals`)** — логическое совпадение значений.
    
- **Идентичность (`ReferenceEquals`)** — указывают ли две переменные на один и тот же объект в памяти.

### 68. Ваше понимание Object.MemberwiseClone

Создает **поверхностную копию** объекта:

- копируются значения полей,
    
- ссылки на объекты остаются теми же (т.е. не глубокая копия).

### 69. Ваше понимание Object.ReferenceEquals

Проверяет, ссылаются ли **две переменные на один и тот же объект**:

`Object.ReferenceEquals(a, b);`

Не зависит от перегрузки `Equals`.

### 70. Ваше понимание понятия "перегрузка операторов"

Позволяет определить собственное поведение стандартных операторов (`+`, `==`, `<`, `>`, и т.д.) для своих типов:

`public static Entity operator ==(Entity a, Entity b) => ...`

### 71. Перегрузка оператора равенства

Дан код:
```csharp
public class Entity 
{ 
	public int Id {get;set;} 
}
```
Замените оператор сравнения таким образом, что экземпляры одного типа считаются равными при совпадении идентификатора (Id)

```csharp
public class Entity
{
    public int Id { get; set; }

    public override bool Equals(object obj)
        => obj is Entity e && Id == e.Id;

    public override int GetHashCode() => Id.GetHashCode();

    public static bool operator ==(Entity a, Entity b)
        => a?.Id == b?.Id;

    public static bool operator !=(Entity a, Entity b)
        => !(a == b);
}
```
### 72. Опишите интерфейс IEqualityComparer и его применение

Интерфейс для **кастомного сравнения объектов** (например, для `Dictionary` или `Distinct`):

## Паттерны проектирования

### 73. Реализацией какого паттерна являются события (event)?

Паттерна **Observer (Наблюдатель)** — объект сообщает подписчикам об изменениях.

### 74. Ваше понимание паттерна Singleton

Обеспечивает, что существует **только один экземпляр класса**.

### 75. Ваше понимание паттерна Abstract Factory

Создает **семейства связанных объектов** без указания конкретных классов.

### 76. Ваше понимание паттерна Factory Method

Делегирует создание объектов **подклассам**.  
Базовый класс определяет интерфейс, наследники решают, какой объект вернуть.

### 77. Ваше понимание паттерна Builder

Разделяет **процесс построения объекта** от его представления.  
Позволяет поэтапно собрать сложный объект (например, создание сложного JSON, SQL-запроса и т.д.).

## Архитектура

### 78. Опишите трехуровневую модель приложения

- **Presentation Layer** — UI (представление, контроллеры).
    
- **Business Logic Layer (BLL)** — логика, правила, сервисы.
    
- **Data Access Layer (DAL)** — работа с базой данных.

### 79. Ваше понимание принципа SOLID

- **S** — Single Responsibility (одна ответственность).
    
- **O** — Open/Closed (открыт для расширения, закрыт для изменения).
    
- **L** — Liskov Substitution (замена наследников не нарушает поведение).
    
- **I** — Interface Segregation (мелкие интерфейсы).
    
- **D** — Dependency Inversion (зависимости от абстракций, не от реализаций).

### 80. Ваше понимание принципа ACID

- **A** — Atomicity (всё или ничего),
    
- **C** — Consistency (согласованность),
    
- **I** — Isolation (изолированность),
    
- **D** — Durability (сохранность после сбоя).

## Миграции и инфраструктура

### 81. Ваше понимание миграции схемы БД. Какие инструменты вы использовали?

Миграции — способ **пошагового изменения структуры БД** с сохранением данных.  
Инструменты:

- **EF Core Migrations**,
    
- **Flyway**,
    
- **Liquibase**,
    
- **FluentMigrator**.  
    Позволяют версионировать схему и автоматически применять изменения.

### 82. Какие задачи решают библиотеки Bars.Gkh.Transport и Bars.Gkh.Queue?

- **Bars.Gkh.Transport** — обработка обмена данными между системами (импорт/экспорт, интеграция).
    
- **Bars.Gkh.Queue** — управление **очередями задач** (фоновая обработка, асинхронные операции).

---

# PostgreSQL

## Основы баз данных

### 83. Виды ключей

- **Primary Key** — уникальный идентификатор записи.
    
- **Foreign Key** — связь с другой таблицей.
    
- **Unique Key** — уникальные значения без PK.
    
- **Composite Key** — составной ключ из нескольких полей.
    
- **Candidate Key** — потенциальные ключи.

### 84. Нормализация и денормализация, когда нужны

- **Нормализация** — устранение дублирования данных (1NF–3NF). Нужна для целостности и меньшего объема.
    
- **Денормализация** — намеренное дублирование ради **скорости** (например, аналитика, отчеты).

### 85. Временные таблицы и представления

- **Временные таблицы (TEMP)** — живут до конца сессии.
    
- **Представления (VIEW)** — виртуальные таблицы, основаны на SELECT-запросе.  
    Позволяют упростить запросы и изолировать данные.

### 86. Быстрая вставка данных в таблицу, быстрая выгрузка данных из таблицы

- Вставка: `COPY table FROM 'file.csv' DELIMITER ',' CSV;`
    
- Выгрузка: `COPY (SELECT ...) TO 'file.csv' CSV;`  
    Быстрее, чем `INSERT`, т.к. работает на уровне файлов.

## Запросы

### 87. Подзапросы

Вложенные SELECT внутри другого SELECT, WHERE или FROM.  
Пример:

`SELECT name FROM users WHERE id IN (SELECT user_id FROM orders);`

### 88. Оконные функции

Выполняют вычисления по “окну” строк без группировки.  
Пример:

`SELECT name, SUM(salary) OVER (PARTITION BY department) FROM employees;`

### 89. EXCEPT, INTERSECT

- `EXCEPT` — разность (строки из первого, которых нет во втором).
    
- `INTERSECT` — пересечение (строки, общие для обоих запросов).

## Типы данных

### 90. Сложные и составные типы данных, массивы

PostgreSQL поддерживает:

- **Composite types** — объединение нескольких полей.
    
- **Array types** — хранение массивов (`int[]`, `text[]`).  
    Позволяют хранить структурированные данные.

### 91. Обработка JSON, JSONB типов

`JSON` — строка JSON,  
`JSONB` — бинарное представление (быстрее, индексируемое).  
Пример:

`SELECT data->'name', data->>'age' FROM users;`

Индексы: `CREATE INDEX ON table USING GIN (data jsonb_path_ops);`

## Логика и производительность

### 92. Логика в БД, хранимые процедуры

Позволяют инкапсулировать бизнес-логику в БД.  
Создаются с помощью `CREATE FUNCTION` или `CREATE PROCEDURE`.  
Поддерживают транзакции, курсоры, параметры.

### 93. Триггеры

Механизм, вызывающий функцию при **определённом событии** (INSERT, UPDATE, DELETE).  
Пример:

`CREATE TRIGGER update_time BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION set_update_time();`

### 94. Оператор EXPLAIN

Показывает **план выполнения запроса** — как PostgreSQL его оптимизирует.  
Пример:

`EXPLAIN ANALYZE SELECT * FROM users WHERE id = 5;`

Используется для анализа производительности (индексы, последовательное/индексное сканирование и т.д.).

---

## Прогресс изучения

### .NET Core
- [ ] Сборка мусора (1-3)
- [ ] Делегаты и события (4-5)
- [ ] Структуры (6-9)
- [ ] LINQ и IQueryable (10-14)
- [ ] IDisposable (15-21)
- [ ] Многопоточность (22-31)
- [ ] Асинхронность (32-34)
- [ ] Атрибуты (35-36)
- [ ] Reflection (37-41)
- [ ] Сборки (42-48)
- [ ] ORM (49-54)
- [ ] IoC/DI (55-66)
- [ ] Равенство объектов (67-72)
- [ ] Паттерны (73-77)
- [ ] Архитектура (78-82)

### PostgreSQL
- [ ] Основы БД (83-86)
- [ ] Запросы (87-89)
- [ ] Типы данных (90-91)
- [ ] Логика и производительность (92-94)

---

## Заметки и дополнительные материалы